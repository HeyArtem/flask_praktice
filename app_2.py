
# уроки с Данилой. Дандер методы


class Point(object):
    # инициализация класса
    def __init__(self, x, y):
        self.x = x
        self.y = y


    # это явный метод, обычная функция, которая выводит значения переменных
    def to_str(self):
        return f'Point({self.x},{self.y})'

    # НЕЯВНЫЕ, магические или ДАНДЕР методы 
    # Переопределение магического(dunder) метода
    def __repr__(self):  # repr()
        return f'Метод __repr__\nPoint({self.x},{self.y})'

    def __str__(self):   # str()
        return (f'Метод: __str__.\nТочка с координатами:'
                f'({self.x},{self.y})')


    


p1 = Point(3, 3)
p2 = Point(4, 4)

# # Пример 1
# # Явно вызываем метод to_str(), обычную функцию
# print('-Вызов явного метода')
# print(p1.to_str())
# print(p2.to_str())
# print("\n")

# '''
# Вызов неявных методов. Дандер методов
# Причем первым сработает __str__, а если его закоментить,
# то вызовется __repr__, если закоментить и его,
# выведутся адреса ячеек памяти, где хранятся переменные

# Вывод: если присутствуют оба метода, то первым сработает __str__, втьорым __repr__(репрезентация)
# '''

# print('-Вызов неявных методов')
# print(p1)
# print(p2)
# print("\n")
''' -> Дандер методы это перепись внутренних методов в питоне <- '''


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Пример 2 #! Данила!!!!!
# Неявно вызываем магические методы __repr__ и __str__
# print сначала ищет __str__(),
# если не находит то использует __repr__()

# print(str(p1))  # str(p1) -> p1.__str__()
# print(repr(p2)) # repr(p1) -> p1.__repr__()


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Пример 3
# print('=' * 40)
# Четыре вызова с одинаковым функционалом
# print(p2)
# print(str(p2))
# print(p2.__str__())  # print(str(p2))
# print(Point.__str__(p2))

# # Пример 4
# # Вызвать именно repr()
# print(p1.__repr__()) # # print(repr(p1))
# print(repr(p1))


# # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# '''
# Пример 5
# s1 - это строка, 
#     но метод __str__ предназначен для чтения людьми
#     а метод __repr__ предназначен для машинно-ориентированного вывода (более того, это часто должен быть валидный код на Питоне)
#     и это видно, str вывел 100
#     repr вывел "100"

# i1 - это число,
#     str -> 100
#     repr -> 100

# Вывод: __repr__ это валидное отображение
# '''
# s1 = "100"  # строка
# print('Метод str(s1): ', str(s1))
# print('Метод repr(s1): ',repr(s1))  # показать как есть
# print("\n")

# i1 = 100    # число
# print('Метод str(i1): ', str(i1))
# print('Метод repr(i1): ', repr(i1))
# print("\n")

# # вывод длины
# print(len(s1))
# print(s1.__len__())

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
from pprint import pprint

# Интроспекция экземпляра p1 (dunder методы)
pprint(dir(p1))
print("\n")
print(dir(p1))
print("\n")


def func(a=5):
    return a

# Интроспекция экземпляра func (dunder методы)
pprint(dir(func))
